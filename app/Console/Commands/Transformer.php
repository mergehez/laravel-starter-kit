<?php

namespace App\Console\Commands;

use App\Enums\AppDisplayLang;
use App\Enums\ArgBaseEnum;
use App\Enums\KeyValueKey;
use App\Enums\MenuItemType;
use App\Enums\PostStatus;
use App\Enums\PostType;
use App\Enums\SpecialPage;
use App\Enums\UserRole;
use Illuminate\Console\Command;
use Illuminate\Support\Arr;
use UnitEnum;

class Transformer extends Command
{
    protected $signature = 'arg:transform {--force}';
    protected $description = 'Command description';
    protected string $sourceDirectory = 'lang';
    protected string $sourceExt = 'json';
    protected ?string $targetPhpDirectory = 'public/lang';

    public function handle(): void
    {
        $enums = [
            self::fromBaseEnum(AppDisplayLang::class),
            self::fromBaseEnum(PostType::class),
            self::fromBaseEnum(PostStatus::class),
            self::fromBaseEnum(KeyValueKey::class),
            self::fromBaseEnum(SpecialPage::class),
            self::fromBaseEnum(UserRole::class),
            self::fromBaseEnum(MenuItemType::class),
        ];


        $contents = [];
        foreach ($enums as $enum) {
            $contents[] = $this->assocToEnum($enum['arr'], $enum['enumName'], $enum['typeName'], $enum['pretty'], $enum['asObject']);
        }
        $contents = "// This file is auto-generated by ArgTransformer. Do not edit it manually!\n\n".implode("\n", $contents);
        $success = file_put_contents('resources/js/utils/generated_enums.ts', $contents);

        if ($success) {
            $this->info(' -> Localization: (Re)converted json to php files.');
        } else {
            $this->error(' -> Localization: Conversion failed.');
        }
    }

    public static function fromBaseEnum(ArgBaseEnum|string $class, bool $asObject = false): array
    {
        // return new EnumDef($class::getAll(), last(explode('\\', $class)), null, true, $asObject);
        return [
            'arr' => $class::getAll(),
            'enumName' => last(explode('\\', $class)),
            'typeName' => null,
            'pretty' => true,
            'asObject' => $asObject,
        ];
    }

    protected function assocToEnum($arr, $enumName, $typeName, $pretty = false, $asObject = false): string
    {
        $res = $this->enumToJsObject($arr, $pretty, $asObject);
        $res = $asObject ? "export const $enumName = $res as const;" : "export enum $enumName $res";
        if ($typeName) {
            $res .= "\nexport type T$typeName = keyof typeof $enumName;";
        }

        return $res;
    }

    private function enumToJsObject($arr, $pretty, $asObject, $depth = 0): string
    {
        $res = [];
        foreach ($arr as $k => $v) {
            $sep = $asObject ? ':' : ' =';

            if ($asObject && str_contains($k, '-')) {
                $k = "'$k'";
            }

            if (is_array($v)) {
                if (!Arr::isAssoc($v)) {
                    $res[] = "$k$sep ".json_encode($v).',';
                } else {
                    $v = $this->enumToJsObject($v, $pretty, $asObject, $depth + 1);
                    $res[] = "$k$sep $v,";
                }
            } else {
                if ($v instanceof UnitEnum) {
                    $k = $v->name;
                    $v = $v->value;
                }
                if (!$asObject && is_int($k)) {
                    $k = "_$k";
                }

                if (is_int($v)) {
                    $res[] = "$k$sep $v,";
                } elseif (str_contains($v, "'")) {
                    $res[] = "$k$sep \"$v\",";
                } else {
                    $res[] = "$k$sep '$v',";
                }
            }
        }
        if ($pretty) {
            $tabs = str_repeat("\t", $depth);
            $res = $tabs.implode("\n\t".$tabs, $res);
        } else {
            $tabs = '';
            $res = implode(' ', $res);
        }

        return "{\n\t$res\n$tabs}";
    }
}